{"tagline":"Prototype ClojureScript functional reactive programming library.","body":"# shafty\r\n\r\nPrototype ClojureScript functional reactive programming library. Shafty\r\nis just an experiment and shouldn't be used in production.  Shafty is\r\ncurrently in development.\r\n\r\nGet in touch if you are interested in helping out.\r\n\r\n## Usage\r\n\r\n### Events\r\n\r\nEvents represent time-varying functions which have a finite set of\r\noccurences over time.  Create an event and generate a receiver for the\r\nevent, which can either be bound to a DOM element via an\r\naddEventListener, set as the callback for a timer, or a result of an\r\nXmlHttpRequest.\r\n\r\n```clojure\r\n(def my-event (shafty/event))\r\n\r\n(def my-event-receiver (shafty/generate-receiver my-event\r\n                                          (fn [x] (identity x))))\r\n```\r\n\r\nCompose event streams using filter!, map!, reduce!, etc.\r\n\r\n```clojure\r\n(def my-filtered-event (shafty/filter! my-event\r\n                                (fn [x] (= 1 x))))\r\n\r\n(def my-mapped-event (shafty/map! my-event\r\n                           (fn [x] (identity 1))))\r\n\r\n(def my-combo-event (shafty/merge! my-filtered-event\r\n                                   my-mapped-event))\r\n\r\n(def my-delayed-event (shafty/delay! my-filtered-event 50000)\r\n```\r\n\r\n### Behaviours\r\n\r\nBehaviours are time-varying functions which constantly have a value.\r\nDerive a behaviour from an event, or generate a receiver to watch a\r\nparticular DOM element, such as an input field.\r\n\r\nBehaviours share the same IEventStream protocol, so you can also use\r\nmerge!, delay!, map!, filter!, etc. to compose them.\r\n\r\nYou can also call changes! to convert a Behaviour back to an Event.\r\n\r\n```clojure\r\n(def my-behaviour-of-ones (shafty/hold! my-filtered-event 1))\r\n\r\n(def my-behaviour-as-event (shafty/changes! my-behaviour-of-ones))\r\n```\r\n\r\n## TODO\r\n\r\n* Add to IEventStream:\r\n  * reduce!\r\n  * ~~merge!~~\r\n  * ~~delay!~~\r\n* Should we abandon watchers?\r\n* Should we refactor swap! calls with -notify-watcher calls. Likely.\r\n* When we propagate records forward, we want to call an update-fn.\r\n* Example applications:\r\n  * Text box auto-save\r\n  * Timer with reset button\r\n\r\n## License\r\n\r\nCopyright (C) 2012 Christopher Meiklejohn.\r\n\r\nDistributed under the Eclipse Public License, the same as Clojure.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Shafty"}